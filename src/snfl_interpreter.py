"""
SNFL Interpreter

This script is the main entry point for the SNFL interpreter. It takes a .snfl file as input,
tokenizes the data, parses the tokens into statements, and then interprets the statements.

In the case of SNFL, it is an interpreted language, so the interpreter will execute the statements
line by line.

The script accepts the following command line options:
    -d: Enable debug mode

The process is divided into the following steps:
1. Tokenization: The input data is broken down into tokens.
2. Parsing: The tokens are parsed into statements.
3. Interpretation: The statements are interpreted and executed.

Usage:
    python snfl_interpreter.py <filename> [-d]
"""

import sys
from colors import Colors
from declaration import Declaration
from print import Print
from operations import Operations
from snfl_parser import SnflParser
from snfl_tokenizer import SnflTokenizer
from type_errors import TypeError

class Config:
    debug = False

    @classmethod
    def set_debug(self, isDebug):
        Config.debug = isDebug

    @classmethod
    def print_debug(self, message):
        if self.debug:
            print(f"{Colors.YELLOW}[DEBUG]{Colors.RESET} {message}")

class Interpreter:
    '''
    The interpreter class is responsible for interpreting the statements
    generated by the parser. It will execute the statements and produce
    the output.
    
    Attributes:
        config (Config): The configuration object.
        statements (list): The list of statements to interpret.
        symbol_table (dict): The symbol table to store variables.
    '''
    def __init__(self, statements) -> None:
        self.statements = statements
        self.symbol_table = {}

    def run(self):
        if (Config.debug):
            Config.print_debug(f"[RUNNING INTERPRETER...]")

        for statement in self.statements:
            self.execute(statement)

    def execute(self, statement):
        statement_type = type(statement)
        switcher = {
            Declaration: self.declare,
            Print: self.print,
            Operations: self.operation
        }
        
        func = switcher.get(statement_type, lambda: "Invalid statement")
        func(statement)

    def declare(self, statement):
        self.symbol_table[statement.identifier] = statement.value
        if (Config.debug):
            Config.print_debug(f"Declared variable '{statement.identifier}' with value '{statement.value}'")

    def print(self, statement):
        value = statement.value
        if value in self.symbol_table:
            if (Config.debug):
                Config.print_debug(f"Printing: {value} (symbol)")
            print(self.symbol_table[value])
        else:
            if (Config.debug):
                Config.print_debug(f"Printing: {value}")
            print(value)
    
    def operation(self, statement):
        # Checks to see if the values are literals or variable references and will populate the left and right side
        # from the symbol table if its a variable otherwise it will use the literal value
        if statement.left in self.symbol_table.keys():
            left = self.symbol_table.get(statement.left)
        else:
            left = statement.left
        if statement.right in self.symbol_table.keys():
            right = self.symbol_table.get(statement.right)
        else:
            right = statement.right

        if not isinstance(left, int):
            raise TypeError("Can only add ints")
        if not isinstance(right,int):
            raise TypeError("Can only add ints")
        
        # checks if the op is add and performs it. 
        if statement.identifier == 'add':
            print(f"Adding {left} and {right}")
            result = left + right
            if statement.dest is not None:
                self.symbol_table[statement.dest] = result
            else:
                print(f"result = {result}")
        
def main():
    # Initial configuration
    if len(sys.argv) < 2:
        print("Usage: python snfl_interpreter.py <filename> [-d]")
        print("Options:")
        print("\t-d: Enable debug mode")
        return

    filename = sys.argv[1]
    debug = '-d' in sys.argv[2:]   

    if not filename.endswith('.snfl'):
        print("Invalid file extension. Only .snfl files are supported.")
        return
    
    Config.set_debug(debug)


    with open(filename, 'r') as file:
        data = file.read()

    # Tokenize the data
    if Config.debug:
        Config.print_debug(f"[TOKENIZING DATA...]")
    tokens = tokenize_data(data)

    # Parse the tokens
    if Config.debug:
        Config.print_debug(f"[PARSING TOKENS...]")
    statements = parse_tokens(tokens)

    # Interpret the statements
    if Config.debug:
        Config.print_debug(f"[INTERPRETING STATEMENTS...]")
    interpret_statements(statements)

def tokenize_data(data):
    '''
    Step 1: Tokenize the data.
    '''
    tokenizer = SnflTokenizer()
    tokenizer.build()
    tokens = tokenizer.tokenize(data)

    if Config.debug:
        for token in tokens:
            Config.print_debug(f"{token}")
    return tokens

def parse_tokens(tokens):
    '''
    Step 2: Parse the tokens.
    '''
    parser = SnflParser(tokens)
    statements = parser.parse()

    if Config.debug:
        for statement in statements:
            Config.print_debug(f"{statement.stmt}")

    return statements

def interpret_statements(statements):
    '''
    Step 3: Interpret the statements.
    '''
    interpreter = Interpreter(statements)
    interpreter.run()

if __name__ == "__main__":
    main()