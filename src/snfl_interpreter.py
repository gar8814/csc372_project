"""
SNFL Interpreter

This script is the main entry point for the SNFL interpreter. It takes a .snfl file as input,
tokenizes the data, parses the tokens into statements, and then interprets the statements.

In the case of SNFL, it is an interpreted language, so the interpreter will execute the statements
line by line.

The script accepts the following command line options:
    -d: Enable debug mode

The process is divided into the following steps:
1. Tokenization: The input data is broken down into tokens.
2. Parsing: The tokens are parsed into statements.
3. Interpretation: The statements are interpreted and executed.

Usage:
    python snfl_interpreter.py <filename> [-d]
"""

import sys
from declaration import Declaration
from snfl_parser import SnflParser
from snfl_tokenizer import SnflTokenizer

class Config:
    def __init__(self, debug=False):
        self.debug = debug

class Interpreter:
    '''
    The interpreter class is responsible for interpreting the statements
    generated by the parser. It will execute the statements and produce
    the output.
    
    Attributes:
        config (Config): The configuration object.
        statements (list): The list of statements to interpret.
        symbol_table (dict): The symbol table to store variables.
    '''
    def __init__(self, config, statements) -> None:
        self.statements = statements
        self.config = config
        self.symbol_table = {}

    def run(self):
        if (self.config.debug):
            print("[RUNNING INTERPRETER...]")

        for statement in self.statements:
            self.execute(statement)

    def execute(self, statement):
        statement_type = type(statement)
        switcher = {
            Declaration: self.declare,
        }
        func = switcher.get(statement_type, lambda: "Invalid statement")
        func(statement)

    def declare(self, statement):
        self.symbol_table[statement.identifier] = statement.value

        if (self.config.debug):
            print(f"Declared variable '{statement.identifier}' with value '{statement.value}'")

def main():
    # Initial configuration
    if len(sys.argv) < 2:
        print("Usage: python snfl_interpreter.py <filename> [-d]")
        print("Options:")
        print("\t-d: Enable debug mode")
        return

    filename = sys.argv[1]
    debug = '-d' in sys.argv[2:]   

    if not filename.endswith('.snfl'):
        print("Invalid file extension. Only .snfl files are supported.")
        return
    
    config = Config(debug)

    with open(filename, 'r') as file:
        data = file.read()

    # Tokenize the data
    if config.debug:
        print("[TOKENIZING DATA...]")
    tokens = tokenize_data(config, data)

    # Parse the tokens
    if config.debug:
        print("[PARSING TOKENS...]")
    statements = parse_tokens(config, tokens)

    # Interpret the statements
    if config.debug:
        print("[INTERPRETING STATEMENTS...]")
    interpret_statements(config, statements)

def tokenize_data(config, data):
    '''
    Step 1: Tokenize the data.
    '''
    print("Step 1: Tokenize Data")
    tokenizer = SnflTokenizer()
    tokenizer.build()
    tokens = tokenizer.tokenize(data)

    if config.debug:
        for token in tokens:
            print(token)
    return tokens

def parse_tokens(config, tokens):
    '''
    Step 2: Parse the tokens.
    '''
    print("Step 2: Parse the tokens")
    parser = SnflParser(tokens)
    statements = parser.parse()

    if config.debug:
        for statement in statements:
            print(statement.stmt)

    return statements

def interpret_statements(config, statements):
    '''
    Step 3: Interpret the statements.
    '''
    interpreter = Interpreter(config, statements)
    interpreter.run()

if __name__ == "__main__":
    main()